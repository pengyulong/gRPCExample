// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: textfeature.proto

#ifndef PROTOBUF_INCLUDED_textfeature_2eproto
#define PROTOBUF_INCLUDED_textfeature_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_textfeature_2eproto 

namespace protobuf_textfeature_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_textfeature_2eproto
namespace textfeature {
class SummaryKeyWords;
class SummaryKeyWordsDefaultTypeInternal;
extern SummaryKeyWordsDefaultTypeInternal _SummaryKeyWords_default_instance_;
class docsRequest;
class docsRequestDefaultTypeInternal;
extern docsRequestDefaultTypeInternal _docsRequest_default_instance_;
class keyResponse;
class keyResponseDefaultTypeInternal;
extern keyResponseDefaultTypeInternal _keyResponse_default_instance_;
class orderkeyResponse;
class orderkeyResponseDefaultTypeInternal;
extern orderkeyResponseDefaultTypeInternal _orderkeyResponse_default_instance_;
class sentenceRequest;
class sentenceRequestDefaultTypeInternal;
extern sentenceRequestDefaultTypeInternal _sentenceRequest_default_instance_;
class textRequest;
class textRequestDefaultTypeInternal;
extern textRequestDefaultTypeInternal _textRequest_default_instance_;
}  // namespace textfeature
namespace google {
namespace protobuf {
template<> ::textfeature::SummaryKeyWords* Arena::CreateMaybeMessage<::textfeature::SummaryKeyWords>(Arena*);
template<> ::textfeature::docsRequest* Arena::CreateMaybeMessage<::textfeature::docsRequest>(Arena*);
template<> ::textfeature::keyResponse* Arena::CreateMaybeMessage<::textfeature::keyResponse>(Arena*);
template<> ::textfeature::orderkeyResponse* Arena::CreateMaybeMessage<::textfeature::orderkeyResponse>(Arena*);
template<> ::textfeature::sentenceRequest* Arena::CreateMaybeMessage<::textfeature::sentenceRequest>(Arena*);
template<> ::textfeature::textRequest* Arena::CreateMaybeMessage<::textfeature::textRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace textfeature {

// ===================================================================

class textRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:textfeature.textRequest) */ {
 public:
  textRequest();
  virtual ~textRequest();

  textRequest(const textRequest& from);

  inline textRequest& operator=(const textRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  textRequest(textRequest&& from) noexcept
    : textRequest() {
    *this = ::std::move(from);
  }

  inline textRequest& operator=(textRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const textRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const textRequest* internal_default_instance() {
    return reinterpret_cast<const textRequest*>(
               &_textRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(textRequest* other);
  friend void swap(textRequest& a, textRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline textRequest* New() const final {
    return CreateMaybeMessage<textRequest>(NULL);
  }

  textRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<textRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const textRequest& from);
  void MergeFrom(const textRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(textRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:textfeature.textRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_textfeature_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class keyResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:textfeature.keyResponse) */ {
 public:
  keyResponse();
  virtual ~keyResponse();

  keyResponse(const keyResponse& from);

  inline keyResponse& operator=(const keyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  keyResponse(keyResponse&& from) noexcept
    : keyResponse() {
    *this = ::std::move(from);
  }

  inline keyResponse& operator=(keyResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const keyResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const keyResponse* internal_default_instance() {
    return reinterpret_cast<const keyResponse*>(
               &_keyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(keyResponse* other);
  friend void swap(keyResponse& a, keyResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline keyResponse* New() const final {
    return CreateMaybeMessage<keyResponse>(NULL);
  }

  keyResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<keyResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const keyResponse& from);
  void MergeFrom(const keyResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(keyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string keywords = 1;
  void clear_keywords();
  static const int kKeywordsFieldNumber = 1;
  const ::std::string& keywords() const;
  void set_keywords(const ::std::string& value);
  #if LANG_CXX11
  void set_keywords(::std::string&& value);
  #endif
  void set_keywords(const char* value);
  void set_keywords(const char* value, size_t size);
  ::std::string* mutable_keywords();
  ::std::string* release_keywords();
  void set_allocated_keywords(::std::string* keywords);

  // @@protoc_insertion_point(class_scope:textfeature.keyResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr keywords_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_textfeature_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class orderkeyResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:textfeature.orderkeyResponse) */ {
 public:
  orderkeyResponse();
  virtual ~orderkeyResponse();

  orderkeyResponse(const orderkeyResponse& from);

  inline orderkeyResponse& operator=(const orderkeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  orderkeyResponse(orderkeyResponse&& from) noexcept
    : orderkeyResponse() {
    *this = ::std::move(from);
  }

  inline orderkeyResponse& operator=(orderkeyResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const orderkeyResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const orderkeyResponse* internal_default_instance() {
    return reinterpret_cast<const orderkeyResponse*>(
               &_orderkeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(orderkeyResponse* other);
  friend void swap(orderkeyResponse& a, orderkeyResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline orderkeyResponse* New() const final {
    return CreateMaybeMessage<orderkeyResponse>(NULL);
  }

  orderkeyResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<orderkeyResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const orderkeyResponse& from);
  void MergeFrom(const orderkeyResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(orderkeyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string keywords = 2;
  void clear_keywords();
  static const int kKeywordsFieldNumber = 2;
  const ::std::string& keywords() const;
  void set_keywords(const ::std::string& value);
  #if LANG_CXX11
  void set_keywords(::std::string&& value);
  #endif
  void set_keywords(const char* value);
  void set_keywords(const char* value, size_t size);
  ::std::string* mutable_keywords();
  ::std::string* release_keywords();
  void set_allocated_keywords(::std::string* keywords);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:textfeature.orderkeyResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr keywords_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_textfeature_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class docsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:textfeature.docsRequest) */ {
 public:
  docsRequest();
  virtual ~docsRequest();

  docsRequest(const docsRequest& from);

  inline docsRequest& operator=(const docsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  docsRequest(docsRequest&& from) noexcept
    : docsRequest() {
    *this = ::std::move(from);
  }

  inline docsRequest& operator=(docsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const docsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const docsRequest* internal_default_instance() {
    return reinterpret_cast<const docsRequest*>(
               &_docsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(docsRequest* other);
  friend void swap(docsRequest& a, docsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline docsRequest* New() const final {
    return CreateMaybeMessage<docsRequest>(NULL);
  }

  docsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<docsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const docsRequest& from);
  void MergeFrom(const docsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(docsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:textfeature.docsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_textfeature_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SummaryKeyWords : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:textfeature.SummaryKeyWords) */ {
 public:
  SummaryKeyWords();
  virtual ~SummaryKeyWords();

  SummaryKeyWords(const SummaryKeyWords& from);

  inline SummaryKeyWords& operator=(const SummaryKeyWords& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SummaryKeyWords(SummaryKeyWords&& from) noexcept
    : SummaryKeyWords() {
    *this = ::std::move(from);
  }

  inline SummaryKeyWords& operator=(SummaryKeyWords&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SummaryKeyWords& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SummaryKeyWords* internal_default_instance() {
    return reinterpret_cast<const SummaryKeyWords*>(
               &_SummaryKeyWords_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SummaryKeyWords* other);
  friend void swap(SummaryKeyWords& a, SummaryKeyWords& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SummaryKeyWords* New() const final {
    return CreateMaybeMessage<SummaryKeyWords>(NULL);
  }

  SummaryKeyWords* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SummaryKeyWords>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SummaryKeyWords& from);
  void MergeFrom(const SummaryKeyWords& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SummaryKeyWords* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keywords = 1;
  int keywords_size() const;
  void clear_keywords();
  static const int kKeywordsFieldNumber = 1;
  const ::std::string& keywords(int index) const;
  ::std::string* mutable_keywords(int index);
  void set_keywords(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keywords(int index, ::std::string&& value);
  #endif
  void set_keywords(int index, const char* value);
  void set_keywords(int index, const char* value, size_t size);
  ::std::string* add_keywords();
  void add_keywords(const ::std::string& value);
  #if LANG_CXX11
  void add_keywords(::std::string&& value);
  #endif
  void add_keywords(const char* value);
  void add_keywords(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keywords() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keywords();

  // @@protoc_insertion_point(class_scope:textfeature.SummaryKeyWords)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keywords_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_textfeature_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class sentenceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:textfeature.sentenceRequest) */ {
 public:
  sentenceRequest();
  virtual ~sentenceRequest();

  sentenceRequest(const sentenceRequest& from);

  inline sentenceRequest& operator=(const sentenceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  sentenceRequest(sentenceRequest&& from) noexcept
    : sentenceRequest() {
    *this = ::std::move(from);
  }

  inline sentenceRequest& operator=(sentenceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const sentenceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sentenceRequest* internal_default_instance() {
    return reinterpret_cast<const sentenceRequest*>(
               &_sentenceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(sentenceRequest* other);
  friend void swap(sentenceRequest& a, sentenceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline sentenceRequest* New() const final {
    return CreateMaybeMessage<sentenceRequest>(NULL);
  }

  sentenceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<sentenceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const sentenceRequest& from);
  void MergeFrom(const sentenceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sentenceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string text = 1;
  int text_size() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text(int index) const;
  ::std::string* mutable_text(int index);
  void set_text(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_text(int index, ::std::string&& value);
  #endif
  void set_text(int index, const char* value);
  void set_text(int index, const char* value, size_t size);
  ::std::string* add_text();
  void add_text(const ::std::string& value);
  #if LANG_CXX11
  void add_text(::std::string&& value);
  #endif
  void add_text(const char* value);
  void add_text(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& text() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_text();

  // @@protoc_insertion_point(class_scope:textfeature.sentenceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_textfeature_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// textRequest

// string text = 1;
inline void textRequest::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& textRequest::text() const {
  // @@protoc_insertion_point(field_get:textfeature.textRequest.text)
  return text_.GetNoArena();
}
inline void textRequest::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:textfeature.textRequest.text)
}
#if LANG_CXX11
inline void textRequest::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:textfeature.textRequest.text)
}
#endif
inline void textRequest::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:textfeature.textRequest.text)
}
inline void textRequest::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:textfeature.textRequest.text)
}
inline ::std::string* textRequest::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:textfeature.textRequest.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* textRequest::release_text() {
  // @@protoc_insertion_point(field_release:textfeature.textRequest.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void textRequest::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:textfeature.textRequest.text)
}

// -------------------------------------------------------------------

// keyResponse

// string keywords = 1;
inline void keyResponse::clear_keywords() {
  keywords_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& keyResponse::keywords() const {
  // @@protoc_insertion_point(field_get:textfeature.keyResponse.keywords)
  return keywords_.GetNoArena();
}
inline void keyResponse::set_keywords(const ::std::string& value) {
  
  keywords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:textfeature.keyResponse.keywords)
}
#if LANG_CXX11
inline void keyResponse::set_keywords(::std::string&& value) {
  
  keywords_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:textfeature.keyResponse.keywords)
}
#endif
inline void keyResponse::set_keywords(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  keywords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:textfeature.keyResponse.keywords)
}
inline void keyResponse::set_keywords(const char* value, size_t size) {
  
  keywords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:textfeature.keyResponse.keywords)
}
inline ::std::string* keyResponse::mutable_keywords() {
  
  // @@protoc_insertion_point(field_mutable:textfeature.keyResponse.keywords)
  return keywords_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* keyResponse::release_keywords() {
  // @@protoc_insertion_point(field_release:textfeature.keyResponse.keywords)
  
  return keywords_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void keyResponse::set_allocated_keywords(::std::string* keywords) {
  if (keywords != NULL) {
    
  } else {
    
  }
  keywords_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keywords);
  // @@protoc_insertion_point(field_set_allocated:textfeature.keyResponse.keywords)
}

// -------------------------------------------------------------------

// orderkeyResponse

// int32 id = 1;
inline void orderkeyResponse::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 orderkeyResponse::id() const {
  // @@protoc_insertion_point(field_get:textfeature.orderkeyResponse.id)
  return id_;
}
inline void orderkeyResponse::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:textfeature.orderkeyResponse.id)
}

// string keywords = 2;
inline void orderkeyResponse::clear_keywords() {
  keywords_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& orderkeyResponse::keywords() const {
  // @@protoc_insertion_point(field_get:textfeature.orderkeyResponse.keywords)
  return keywords_.GetNoArena();
}
inline void orderkeyResponse::set_keywords(const ::std::string& value) {
  
  keywords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:textfeature.orderkeyResponse.keywords)
}
#if LANG_CXX11
inline void orderkeyResponse::set_keywords(::std::string&& value) {
  
  keywords_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:textfeature.orderkeyResponse.keywords)
}
#endif
inline void orderkeyResponse::set_keywords(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  keywords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:textfeature.orderkeyResponse.keywords)
}
inline void orderkeyResponse::set_keywords(const char* value, size_t size) {
  
  keywords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:textfeature.orderkeyResponse.keywords)
}
inline ::std::string* orderkeyResponse::mutable_keywords() {
  
  // @@protoc_insertion_point(field_mutable:textfeature.orderkeyResponse.keywords)
  return keywords_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* orderkeyResponse::release_keywords() {
  // @@protoc_insertion_point(field_release:textfeature.orderkeyResponse.keywords)
  
  return keywords_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void orderkeyResponse::set_allocated_keywords(::std::string* keywords) {
  if (keywords != NULL) {
    
  } else {
    
  }
  keywords_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keywords);
  // @@protoc_insertion_point(field_set_allocated:textfeature.orderkeyResponse.keywords)
}

// -------------------------------------------------------------------

// docsRequest

// int32 id = 1;
inline void docsRequest::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 docsRequest::id() const {
  // @@protoc_insertion_point(field_get:textfeature.docsRequest.id)
  return id_;
}
inline void docsRequest::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:textfeature.docsRequest.id)
}

// string text = 2;
inline void docsRequest::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& docsRequest::text() const {
  // @@protoc_insertion_point(field_get:textfeature.docsRequest.text)
  return text_.GetNoArena();
}
inline void docsRequest::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:textfeature.docsRequest.text)
}
#if LANG_CXX11
inline void docsRequest::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:textfeature.docsRequest.text)
}
#endif
inline void docsRequest::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:textfeature.docsRequest.text)
}
inline void docsRequest::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:textfeature.docsRequest.text)
}
inline ::std::string* docsRequest::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:textfeature.docsRequest.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* docsRequest::release_text() {
  // @@protoc_insertion_point(field_release:textfeature.docsRequest.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void docsRequest::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:textfeature.docsRequest.text)
}

// -------------------------------------------------------------------

// SummaryKeyWords

// repeated string keywords = 1;
inline int SummaryKeyWords::keywords_size() const {
  return keywords_.size();
}
inline void SummaryKeyWords::clear_keywords() {
  keywords_.Clear();
}
inline const ::std::string& SummaryKeyWords::keywords(int index) const {
  // @@protoc_insertion_point(field_get:textfeature.SummaryKeyWords.keywords)
  return keywords_.Get(index);
}
inline ::std::string* SummaryKeyWords::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:textfeature.SummaryKeyWords.keywords)
  return keywords_.Mutable(index);
}
inline void SummaryKeyWords::set_keywords(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:textfeature.SummaryKeyWords.keywords)
  keywords_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SummaryKeyWords::set_keywords(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:textfeature.SummaryKeyWords.keywords)
  keywords_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SummaryKeyWords::set_keywords(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:textfeature.SummaryKeyWords.keywords)
}
inline void SummaryKeyWords::set_keywords(int index, const char* value, size_t size) {
  keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:textfeature.SummaryKeyWords.keywords)
}
inline ::std::string* SummaryKeyWords::add_keywords() {
  // @@protoc_insertion_point(field_add_mutable:textfeature.SummaryKeyWords.keywords)
  return keywords_.Add();
}
inline void SummaryKeyWords::add_keywords(const ::std::string& value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:textfeature.SummaryKeyWords.keywords)
}
#if LANG_CXX11
inline void SummaryKeyWords::add_keywords(::std::string&& value) {
  keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:textfeature.SummaryKeyWords.keywords)
}
#endif
inline void SummaryKeyWords::add_keywords(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:textfeature.SummaryKeyWords.keywords)
}
inline void SummaryKeyWords::add_keywords(const char* value, size_t size) {
  keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:textfeature.SummaryKeyWords.keywords)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SummaryKeyWords::keywords() const {
  // @@protoc_insertion_point(field_list:textfeature.SummaryKeyWords.keywords)
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SummaryKeyWords::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:textfeature.SummaryKeyWords.keywords)
  return &keywords_;
}

// -------------------------------------------------------------------

// sentenceRequest

// repeated string text = 1;
inline int sentenceRequest::text_size() const {
  return text_.size();
}
inline void sentenceRequest::clear_text() {
  text_.Clear();
}
inline const ::std::string& sentenceRequest::text(int index) const {
  // @@protoc_insertion_point(field_get:textfeature.sentenceRequest.text)
  return text_.Get(index);
}
inline ::std::string* sentenceRequest::mutable_text(int index) {
  // @@protoc_insertion_point(field_mutable:textfeature.sentenceRequest.text)
  return text_.Mutable(index);
}
inline void sentenceRequest::set_text(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:textfeature.sentenceRequest.text)
  text_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void sentenceRequest::set_text(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:textfeature.sentenceRequest.text)
  text_.Mutable(index)->assign(std::move(value));
}
#endif
inline void sentenceRequest::set_text(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  text_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:textfeature.sentenceRequest.text)
}
inline void sentenceRequest::set_text(int index, const char* value, size_t size) {
  text_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:textfeature.sentenceRequest.text)
}
inline ::std::string* sentenceRequest::add_text() {
  // @@protoc_insertion_point(field_add_mutable:textfeature.sentenceRequest.text)
  return text_.Add();
}
inline void sentenceRequest::add_text(const ::std::string& value) {
  text_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:textfeature.sentenceRequest.text)
}
#if LANG_CXX11
inline void sentenceRequest::add_text(::std::string&& value) {
  text_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:textfeature.sentenceRequest.text)
}
#endif
inline void sentenceRequest::add_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  text_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:textfeature.sentenceRequest.text)
}
inline void sentenceRequest::add_text(const char* value, size_t size) {
  text_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:textfeature.sentenceRequest.text)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
sentenceRequest::text() const {
  // @@protoc_insertion_point(field_list:textfeature.sentenceRequest.text)
  return text_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
sentenceRequest::mutable_text() {
  // @@protoc_insertion_point(field_mutable_list:textfeature.sentenceRequest.text)
  return &text_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace textfeature

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_textfeature_2eproto
